/* keyboard.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';
import { getEngine, focus } from '../core/state/engine.svelte.js';
import { getDebugPanel } from '../debug/debug-panel.svelte.js';

const engine = getEngine();
const debug = getDebugPanel();
const listeners = new Set();

const KEY_MAP = {
	"\x1B[A": "ArrowUp",
	"\x1B[B": "ArrowDown",
	"\x1B[C": "ArrowRight",
	"\x1B[D": "ArrowLeft",
	"\x1B[H": "Home",
	"\x1B[F": "End",
	"\x1B[5~": "PageUp",
	"\x1B[6~": "PageDown",
	"\t": "Tab",
	"\x1B[Z": "Shift+Tab",
	"\r": "Enter",
	"\x1B": "Escape",
	"": "Backspace",
	"\b": "Backspace",
	"\x1B[3~": "Delete",
	"\x03": "Ctrl+C",
	"\x01": "Ctrl+A",
	"\x05": "Ctrl+E",
	"\v": "Ctrl+K",
	"\x15": "Ctrl+U",
	"\x10": "Ctrl+P"
};

let initialized = false;

function initialize() {
	if (initialized || !process.stdin.isTTY) return;

	initialized = true;
	process.stdin.setRawMode(true);
	process.stdin.resume();
	process.stdin.setEncoding("utf8");

	process.stdin.on("data", (data) => {
		const raw = data.toString();
		const key = KEY_MAP[raw] || raw;

		const event = {
			key,
			raw,
			ctrlKey: key.includes("Ctrl+") || raw.charCodeAt(0) < 32 && $.strict_equals(raw, "\t", false) && $.strict_equals(raw, "\r", false) && $.strict_equals(raw, "\x1B", false),
			shiftKey: key.includes("Shift+") || raw >= "A" && raw <= "Z",
			altKey: key.includes("Alt+"),
			metaKey: key.includes("Meta+")
		};

		debug().updateKey(key, raw);

		if ($.strict_equals(key, "Ctrl+C")) {
			cleanup();
			process.exit(0);
		}

		if ($.strict_equals(key, "Ctrl+P")) {
			debug().toggle();

			return;
		}

		for (const handler of listeners) {
			const consumed = handler(event);

			if ($.strict_equals(consumed, true)) break;
		}
	});
}

function cleanup() {
	initialized = false;
	listeners.clear();

	if (process.stdin.isTTY && process.stdin.setRawMode) {
		process.stdin.setRawMode(false);
		process.stdin.pause();
	}

	process.stdout.write("\x1B[?25h");
}

export function on(handler) {
	if (!initialized) initialize();

	listeners.add(handler);

	return () => {
		listeners.delete(handler);
	};
}

export function onKey(key, handler) {
	const keys = Array.isArray(key) ? key : [key];

	return on((event) => {
		if (keys.includes(event.key)) {
			handler();

			return true;
		}
	});
}

export function onFocused(index, handler) {
	return on((event) => {
		if ($.strict_equals(focus.value, index)) {
			return handler(event);
		}
	});
}

export function focusNext() {
	const next = engine().nextFocusableIndex;

	if ($.strict_equals(next, -1, false)) {
		focus.value = next;
	}
}

export function focusPrevious() {
	const prev = engine().previousFocusableIndex;

	if ($.strict_equals(prev, -1, false)) {
		focus.value = prev;
	}
}

export function clearFocus() {
	focus.value = -1;
}

export const keyboard = {
	on,
	onKey,
	onFocused,
	focusNext,
	focusPrevious,
	clearFocus,
	initialize,
	cleanup
};