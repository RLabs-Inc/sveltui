/* focus-context.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';
import { getContext, setContext } from "svelte";

const FOCUS_CONTEXT_KEY = Symbol("sveltui:focus");

class FocusContextImpl {
	#focusedElement = $.tag($.state(null), 'FocusContextImpl.focusedElement');

	get focusedElement() {
		return $.get(this.#focusedElement);
	}

	set focusedElement(value) {
		$.set(this.#focusedElement, value, true);
	}

	#focusHistory = $.tag($.state($.proxy([])), 'FocusContextImpl.focusHistory');

	get focusHistory() {
		return $.get(this.#focusHistory);
	}

	set focusHistory(value) {
		$.set(this.#focusHistory, value, true);
	}

	#registeredElements = $.tag($.state($.proxy(new Set())), 'FocusContextImpl.registeredElements');

	get registeredElements() {
		return $.get(this.#registeredElements);
	}

	set registeredElements(value) {
		$.set(this.#registeredElements, value, true);
	}

	#focusTrapContainer = $.tag($.state(null), 'FocusContextImpl.focusTrapContainer');

	get focusTrapContainer() {
		return $.get(this.#focusTrapContainer);
	}

	set focusTrapContainer(value) {
		$.set(this.#focusTrapContainer, value, true);
	}

	#focusableElements = $.tag(
		$.derived(() => () => {
			const elements = [];
			const container = this.focusTrapContainer || null;
			const elementsToCheck = Array.from(this.registeredElements);

			for (const element of elementsToCheck) {
				const focusable = $.strict_equals(element.getAttribute("focusable"), false, false);
				const disabled = $.strict_equals(element.getAttribute("disabled"), true);
				const hidden = $.strict_equals(element.getAttribute("hidden"), true);

				if (!focusable || disabled || hidden) continue;

				if (container && !this.isDescendantOf(element, container)) {
					continue;
				}

				const tabIndex = element.getAttribute("tabIndex") ?? 0;

				elements.push({
					element,
					tabIndex: $.strict_equals(typeof tabIndex, "number") ? tabIndex : parseInt(tabIndex, 10) || 0,
					focusable: true
				});
			}

			return elements.filter((el) => el.tabIndex >= 0).sort((a, b) => {
				if (a.tabIndex > 0 && b.tabIndex > 0) return a.tabIndex - b.tabIndex;
				if (a.tabIndex > 0) return -1;
				if (b.tabIndex > 0) return 1;

				return 0;
			});
		}),
		'FocusContextImpl.focusableElements'
	);

	get focusableElements() {
		return $.get(this.#focusableElements);
	}

	set focusableElements(value) {
		$.set(this.#focusableElements, value);
	}

	#currentFocusIndex = $.tag(
		$.derived(() => () => {
			if (!this.focusedElement) return -1;

			return this.focusableElements.findIndex((f) => $.strict_equals(f.element, this.focusedElement));
		}),
		'FocusContextImpl.currentFocusIndex'
	);

	get currentFocusIndex() {
		return $.get(this.#currentFocusIndex);
	}

	set currentFocusIndex(value) {
		$.set(this.#currentFocusIndex, value);
	}

	#canFocusNext = $.tag(
		$.derived(() => () => {
			return this.focusableElements.length > 0 && this.currentFocusIndex < this.focusableElements.length - 1;
		}),
		'FocusContextImpl.canFocusNext'
	);

	get canFocusNext() {
		return $.get(this.#canFocusNext);
	}

	set canFocusNext(value) {
		$.set(this.#canFocusNext, value);
	}

	#canFocusPrevious = $.tag(
		$.derived(() => () => {
			return this.focusableElements.length > 0 && this.currentFocusIndex > 0;
		}),
		'FocusContextImpl.canFocusPrevious'
	);

	get canFocusPrevious() {
		return $.get(this.#canFocusPrevious);
	}

	set canFocusPrevious(value) {
		$.set(this.#canFocusPrevious, value);
	}

	constructor() {
		$.user_effect(() => {
			const screen = this.getScreen();

			if (!screen) return;

			const handleTab = (ch, key) => {
				if ($.strict_equals(key.name, "tab")) {
					if (key.shift) {
						this.focusPrevious();
					} else {
						this.focusNext();
					}
				}
			};

			screen.on("keypress", handleTab);

			return () => {
				screen.off("keypress", handleTab);
			};
		});
	}

	focus(element) {
		if (!this.registeredElements.has(element)) return;
		if ($.strict_equals(element.getAttribute("focusable"), false)) return;
		if ($.strict_equals(element.getAttribute("disabled"), true)) return;
		if ($.strict_equals(element.getAttribute("hidden"), true)) return;

		if (this.focusedElement && $.strict_equals(this.focusedElement, element, false)) {
			this.blur();
		}

		this.focusedElement = element;

		const terminalElement = element._terminalElement;

		if (terminalElement && "focus" in terminalElement) {
			terminalElement.focus();
		}

		const focusEvent = new Event("focus");

		element.dispatchEvent?.(focusEvent);
	}

	blur() {
		if (!this.focusedElement) return;

		const element = this.focusedElement;

		this.focusedElement = null;

		const terminalElement = element._terminalElement;

		if (terminalElement && "blur" in terminalElement) {
			terminalElement.blur();
		}

		const blurEvent = new Event("blur");

		element.dispatchEvent?.(blurEvent);
	}

	focusNext() {
		const elements = this.focusableElements;

		if ($.strict_equals(elements.length, 0)) return;

		let nextIndex = this.currentFocusIndex + 1;

		if (nextIndex >= elements.length) {
			nextIndex = 0;
		}

		this.focus(elements[nextIndex].element);
	}

	focusPrevious() {
		const elements = this.focusableElements;

		if ($.strict_equals(elements.length, 0)) return;

		let prevIndex = this.currentFocusIndex - 1;

		if (prevIndex < 0) {
			prevIndex = elements.length - 1;
		}

		this.focus(elements[prevIndex].element);
	}

	registerElement(element) {
		this.registeredElements.add(element);
	}

	unregisterElement(element) {
		this.registeredElements.delete(element);

		if ($.strict_equals(this.focusedElement, element)) {
			this.blur();
		}

		this.focusHistory = this.focusHistory.filter((el) => $.strict_equals(el, element, false));
	}

	pushFocusHistory(element) {
		if (this.focusHistory.length >= 10) {
			this.focusHistory = this.focusHistory.slice(-9);
		}

		this.focusHistory.push(element);
	}

	restoreFocus() {
		while (this.focusHistory.length > 0) {
			const element = this.focusHistory.pop();

			if (this.registeredElements.has(element) && $.strict_equals(element.getAttribute("focusable"), false, false) && $.strict_equals(element.getAttribute("disabled"), true, false) && $.strict_equals(element.getAttribute("hidden"), true, false)) {
				this.focus(element);

				return;
			}
		}

		if (this.focusableElements.length > 0) {
			this.focus(this.focusableElements[0].element);
		}
	}

	trapFocus(container) {
		this.focusTrapContainer = container;

		const firstElement = this.focusableElements[0];

		if (firstElement) {
			this.focus(firstElement.element);
		}
	}

	releaseFocusTrap() {
		this.focusTrapContainer = null;
	}

	isDescendantOf(element, ancestor) {
		let current = element.parentNode;

		while (current) {
			if ($.strict_equals(current, ancestor)) return true;

			current = current.parentNode;
		}

		return false;
	}

	getScreen() {
		if (this.registeredElements.size > 0) {
			const element = Array.from(this.registeredElements)[0];
			const terminalElement = element._terminalElement;

			if (terminalElement && "screen" in terminalElement) {
				return terminalElement.screen;
			}
		}

		return null;
	}
}

export function createFocusContext() {
	const context = new FocusContextImpl();

	setContext(FOCUS_CONTEXT_KEY, context);

	return context;
}

export function getFocusContext() {
	const context = getContext(FOCUS_CONTEXT_KEY);

	if (!context) {
		throw new Error("Focus context not found. Make sure to call createFocusContext() at the root of your app.");
	}

	return context;
}

export function hasFocusContext() {
	try {
		getContext(FOCUS_CONTEXT_KEY);

		return true;
	} catch {
		return false;
	}
}