/* reactive-layout.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';
import { applyLayout } from "./index";
import { applyYogaLayout } from "./yoga";

export var InvalidationReason;

((InvalidationReason) => {
	InvalidationReason["SCREEN_RESIZE"] = "screen_resize";
	InvalidationReason["PARENT_RESIZE"] = "parent_resize";
	InvalidationReason["CONTENT_CHANGE"] = "content_change";
	InvalidationReason["SIBLING_CHANGE"] = "sibling_change";
	InvalidationReason["PROPS_CHANGE"] = "props_change";
	InvalidationReason["HIERARCHY_CHANGE"] = "hierarchy_change";
})(InvalidationReason ||= {});

class LayoutState {
	element;

	#dependencies = $.tag(
		$.state($.proxy({
			parentWidth: 0,
			parentHeight: 0,
			screenWidth: 0,
			screenHeight: 0
		})),
		'LayoutState.dependencies'
	);

	get dependencies() {
		return $.get(this.#dependencies);
	}

	set dependencies(value) {
		$.set(this.#dependencies, value, true);
	}

	#isDirty = $.tag($.state(true), 'LayoutState.isDirty');

	get isDirty() {
		return $.get(this.#isDirty);
	}

	set isDirty(value) {
		$.set(this.#isDirty, value, true);
	}

	#invalidationReason = $.tag($.state(null), 'LayoutState.invalidationReason');

	get invalidationReason() {
		return $.get(this.#invalidationReason);
	}

	set invalidationReason(value) {
		$.set(this.#invalidationReason, value, true);
	}

	#layoutOptions = $.tag($.state($.proxy({})), 'LayoutState.layoutOptions');

	get layoutOptions() {
		return $.get(this.#layoutOptions);
	}

	set layoutOptions(value) {
		$.set(this.#layoutOptions, value, true);
	}

	#useYoga = $.tag($.state(false), 'LayoutState.useYoga');

	get useYoga() {
		return $.get(this.#useYoga);
	}

	set useYoga(value) {
		$.set(this.#useYoga, value, true);
	}

	#computedLayout = $.tag(
		$.derived(() => {
			if (!this.isDirty) {
				return this._lastComputedLayout;
			}

			const layout = this.calculateLayout();

			this._lastComputedLayout = layout;

			queueMicrotask(() => {
				this.isDirty = false;
				this.invalidationReason = null;
			});

			return layout;
		}),
		'LayoutState.computedLayout'
	);

	get computedLayout() {
		return $.get(this.#computedLayout);
	}

	set computedLayout(value) {
		$.set(this.#computedLayout, value);
	}

	_lastComputedLayout = { x: 0, y: 0, width: 0, height: 0 };

	constructor(element) {
		this.element = element;
	}

	invalidate(reason) {
		this.isDirty = true;
		this.invalidationReason = reason;
	}

	updateDependencies(deps) {
		let hasChanges = false;
		let reason = null;

		if ($.strict_equals(deps.screenWidth, undefined, false) && $.strict_equals(deps.screenWidth, this.dependencies.screenWidth, false)) {
			hasChanges = true;
			reason = "screen_resize"; /* SCREEN_RESIZE */
		}

		if ($.strict_equals(deps.screenHeight, undefined, false) && $.strict_equals(deps.screenHeight, this.dependencies.screenHeight, false)) {
			hasChanges = true;
			reason = "screen_resize"; /* SCREEN_RESIZE */
		}

		if ($.strict_equals(deps.parentWidth, undefined, false) && $.strict_equals(deps.parentWidth, this.dependencies.parentWidth, false)) {
			hasChanges = true;
			reason = reason || "parent_resize"; /* PARENT_RESIZE */
		}

		if ($.strict_equals(deps.parentHeight, undefined, false) && $.strict_equals(deps.parentHeight, this.dependencies.parentHeight, false)) {
			hasChanges = true;
			reason = reason || "parent_resize"; /* PARENT_RESIZE */
		}

		if ($.strict_equals(deps.contentWidth, undefined, false) && $.strict_equals(deps.contentWidth, this.dependencies.contentWidth, false)) {
			hasChanges = true;
			reason = reason || "content_change"; /* CONTENT_CHANGE */
		}

		if ($.strict_equals(deps.contentHeight, undefined, false) && $.strict_equals(deps.contentHeight, this.dependencies.contentHeight, false)) {
			hasChanges = true;
			reason = reason || "content_change"; /* CONTENT_CHANGE */
		}

		if (hasChanges) {
			this.dependencies = { ...this.dependencies, ...deps };

			if (reason) {
				this.invalidate(reason);
			}
		}
	}

	calculateLayout() {
		if (this.useYoga && this.element.parent) {
			return {
				x: this.element.props.left || 0,
				y: this.element.props.top || 0,
				width: this.element.props.width || this.dependencies.parentWidth,
				height: this.element.props.height || this.dependencies.parentHeight
			};
		}

		const { parentWidth, parentHeight, contentWidth, contentHeight } = this.dependencies;
		let width;

		if ($.strict_equals(typeof this.element.props.width, "number")) {
			width = this.element.props.width;
		} else if ($.strict_equals(this.element.props.width, "shrink") && contentWidth) {
			width = contentWidth;
		} else if ($.strict_equals(typeof this.element.props.width, "string") && this.element.props.width.endsWith("%")) {
			const percent = parseFloat(this.element.props.width);

			width = Math.floor(parentWidth * (percent / 100));
		} else {
			width = parentWidth;
		}

		let height;

		if ($.strict_equals(typeof this.element.props.height, "number")) {
			height = this.element.props.height;
		} else if ($.strict_equals(this.element.props.height, "shrink") && contentHeight) {
			height = contentHeight;
		} else if ($.strict_equals(typeof this.element.props.height, "string") && this.element.props.height.endsWith("%")) {
			const percent = parseFloat(this.element.props.height);

			height = Math.floor(parentHeight * (percent / 100));
		} else {
			height = parentHeight;
		}

		let x = 0;
		let y = 0;

		if ($.strict_equals(typeof this.element.props.left, "number")) {
			x = this.element.props.left;
		} else if ($.strict_equals(this.element.props.left, "center")) {
			x = Math.floor((parentWidth - width) / 2);
		} else if ($.strict_equals(typeof this.element.props.left, "string") && this.element.props.left.endsWith("%")) {
			const percent = parseFloat(this.element.props.left);

			x = Math.floor(parentWidth * (percent / 100));
		}

		if ($.strict_equals(typeof this.element.props.top, "number")) {
			y = this.element.props.top;
		} else if ($.strict_equals(this.element.props.top, "center")) {
			y = Math.floor((parentHeight - height) / 2);
		} else if ($.strict_equals(typeof this.element.props.top, "string") && this.element.props.top.endsWith("%")) {
			const percent = parseFloat(this.element.props.top);

			y = Math.floor(parentHeight * (percent / 100));
		}

		return { x, y, width, height };
	}
}

export class ReactiveLayoutManager {
	layoutStates = new WeakMap();
	screen = null;
	#screenDimensions = $.tag($.state($.proxy({ width: 80, height: 24 })), 'ReactiveLayoutManager.screenDimensions');

	get screenDimensions() {
		return $.get(this.#screenDimensions);
	}

	set screenDimensions(value) {
		$.set(this.#screenDimensions, value, true);
	}

	constructor() {
		$.user_effect(() => {
			if (!this.screen) return;

			const handleResize = () => {
				this.screenDimensions = { width: this.screen.width, height: this.screen.height };
			};

			this.screen.on("resize", handleResize);

			return () => {
				this.screen?.removeListener("resize", handleResize);
			};
		});
	}

	setScreen(screen) {
		this.screen = screen;
		this.screenDimensions = { width: screen.width, height: screen.height };
	}

	getLayoutState(element) {
		let state = this.layoutStates.get(element);

		if (!state) {
			state = new LayoutState(element);
			this.layoutStates.set(element, state);
		}

		return state;
	}

	updateElementDependencies(element, deps) {
		const state = this.getLayoutState(element);

		state.updateDependencies({
			...deps,
			screenWidth: this.screenDimensions.width,
			screenHeight: this.screenDimensions.height
		});
	}

	applyElementLayout(element, options) {
		const state = this.getLayoutState(element);

		if (options) {
			state.layoutOptions = options;
			state.useYoga = "flexDirection" in options;
		}

		const layout = state.computedLayout;

		if ($.strict_equals(element.props.left, layout.x, false) || $.strict_equals(element.props.top, layout.y, false) || $.strict_equals(element.props.width, layout.width, false) || $.strict_equals(element.props.height, layout.height, false)) {
			element.setProps({
				...element.props,
				left: layout.x,
				top: layout.y,
				width: layout.width,
				height: layout.height
			});
		}

		if (element.children.length > 0) {
			if (state.useYoga) {
				applyYogaLayout(element, layout.width, layout.height, state.layoutOptions);
			} else {
				applyLayout(element, state.layoutOptions);
			}

			for (const child of element.children) {
				this.updateElementDependencies(child, { parentWidth: layout.width, parentHeight: layout.height });
			}
		}
	}

	invalidateElement(element, reason, recursive = false) {
		const state = this.layoutStates.get(element);

		if (state) {
			state.invalidate(reason);
		}

		if (recursive) {
			for (const child of element.children) {
				this.invalidateElement(child, reason, true);
			}
		}
	}

	cleanupElement(element) {
		this.layoutStates.delete(element);
	}
}

export const layoutManager = new ReactiveLayoutManager();