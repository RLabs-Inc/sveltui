/* layout-context.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';
import { layoutManager } from './reactive-layout.svelte.js';

export class LayoutContext {
	screen = null;
	hierarchy = new Map();
	constraints = new WeakMap();
	rules = new WeakMap();
	#screenDimensions = $.tag($.state($.proxy({ width: 80, height: 24 })), 'LayoutContext.screenDimensions');

	get screenDimensions() {
		return $.get(this.#screenDimensions);
	}

	set screenDimensions(value) {
		$.set(this.#screenDimensions, value, true);
	}

	#rootElements = $.tag($.state($.proxy(new Set())), 'LayoutContext.rootElements');

	get rootElements() {
		return $.get(this.#rootElements);
	}

	set rootElements(value) {
		$.set(this.#rootElements, value, true);
	}

	constructor() {
		$.user_effect(() => {
			const dims = layoutManager.screenDimensions;

			this.screenDimensions = { width: dims.width, height: dims.height };
		});
	}

	setScreen(screen) {
		this.screen = screen;
		layoutManager.setScreen(screen);
	}

	registerElement(element, parent = null) {
		const entry = {
			element,
			parent,
			children: new Set(),
			depth: parent ? (this.hierarchy.get(parent)?.depth || 0) + 1 : 0
		};

		this.hierarchy.set(element, entry);

		if (parent) {
			const parentEntry = this.hierarchy.get(parent);

			if (parentEntry) {
				parentEntry.children.add(element);
			}
		} else {
			this.rootElements.add(element);
		}

		this.updateElementContext(element);
	}

	unregisterElement(element) {
		const entry = this.hierarchy.get(element);

		if (!entry) return;

		if (entry.parent) {
			const parentEntry = this.hierarchy.get(entry.parent);

			if (parentEntry) {
				parentEntry.children.delete(element);
			}
		} else {
			this.rootElements.delete(element);
		}

		this.hierarchy.delete(element);
		layoutManager.cleanupElement(element);
	}

	reparentElement(element, newParent) {
		const entry = this.hierarchy.get(element);

		if (!entry) return;

		if (entry.parent) {
			const oldParentEntry = this.hierarchy.get(entry.parent);

			if (oldParentEntry) {
				oldParentEntry.children.delete(element);
			}
		} else {
			this.rootElements.delete(element);
		}

		entry.parent = newParent;

		if (newParent) {
			const newParentEntry = this.hierarchy.get(newParent);

			if (newParentEntry) {
				newParentEntry.children.add(element);
			}

			entry.depth = (newParentEntry?.depth || 0) + 1;
		} else {
			this.rootElements.add(element);
			entry.depth = 0;
		}

		this.updateElementContext(element);
		layoutManager.invalidateElement(element, "hierarchy_change", true);
	}

	setConstraints(element, constraints) {
		this.constraints.set(element, constraints);
		layoutManager.invalidateElement(element, "props_change");
	}

	getConstraints(element) {
		return this.constraints.get(element) || {};
	}

	setRules(element, rules) {
		this.rules.set(element, rules);
	}

	getRules(element) {
		return this.rules.get(element) || {};
	}

	getContextData(element) {
		const entry = this.hierarchy.get(element);
		const parent = entry?.parent || null;
		let parentWidth = this.screenDimensions.width;
		let parentHeight = this.screenDimensions.height;

		if (parent && parent.blessed) {
			parentWidth = parent.blessed.width || parentWidth;
			parentHeight = parent.blessed.height || parentHeight;
		}

		return {
			screenWidth: this.screenDimensions.width,
			screenHeight: this.screenDimensions.height,
			parent,
			parentWidth,
			parentHeight,
			constraints: this.getConstraints(element),
			rules: this.getRules(element)
		};
	}

	updateElementContext(element) {
		const context = this.getContextData(element);

		layoutManager.updateElementDependencies(element, {
			parentWidth: context.parentWidth,
			parentHeight: context.parentHeight,
			screenWidth: context.screenWidth,
			screenHeight: context.screenHeight
		});
	}

	applyLayoutWithConstraints(element, options) {
		const constraints = this.getConstraints(element);
		const rules = this.getRules(element);

		if (constraints || rules) {
			const constrainedOptions = this.applyConstraintsToOptions(options || {}, constraints, rules);

			layoutManager.applyElementLayout(element, constrainedOptions);
		} else {
			layoutManager.applyElementLayout(element, options);
		}

		if (rules.autoReflow) {
			for (const child of element.children) {
				this.applyLayoutWithConstraints(child);
			}
		}
	}

	applyConstraintsToOptions(options, constraints, rules) {
		const constrained = { ...options };

		if ("minWidth" in constraints || "maxWidth" in constraints) {
			Object.assign(constrained, {
				minWidth: constraints.minWidth,
				maxWidth: constraints.maxWidth
			});
		}

		if ("minHeight" in constraints || "maxHeight" in constraints) {
			Object.assign(constrained, {
				minHeight: constraints.minHeight,
				maxHeight: constraints.maxHeight
			});
		}

		return constrained;
	}

	getElementsByDepth(depth) {
		const elements = [];

		for (const [element, entry] of this.hierarchy) {
			if ($.strict_equals(entry.depth, depth)) {
				elements.push(element);
			}
		}

		return elements;
	}

	getElementDepth(element) {
		return this.hierarchy.get(element)?.depth || 0;
	}

	getChildren(element) {
		return this.hierarchy.get(element)?.children || new Set();
	}

	traverseHierarchy(callback, startElement) {
		const visit = (el, depth) => {
			callback(el, depth);

			const children = this.getChildren(el);

			for (const child of children) {
				visit(child, depth + 1);
			}
		};

		if (startElement) {
			visit(startElement, 0);
		} else {
			for (const root of this.rootElements) {
				visit(root, 0);
			}
		}
	}
}

export const layoutContext = new LayoutContext();