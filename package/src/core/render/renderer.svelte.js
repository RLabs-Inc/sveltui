/* renderer.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';

import {
	registry,
	parentIndex,
	childIndices,
	terminalSize,
	componentType,
	ComponentType,
	computedX,
	computedY,
	computedWidth,
	computedHeight,
	visibility,
	zIndex,
	opacity,
	texts,
	wrappedLines,
	colors,
	textStyles,
	borderStyles,
	borderColors,
	borderTop,
	borderBottom,
	borderLeft,
	borderRight,
	scrollOffset,
	scrollOffsetX,
	scrollable,
	focus,
	cursorPosition,
	selectionStart,
	selectionEnd,
	hitGrid,
	getEngine
} from '../state/engine.svelte.js';

import { contentHeight } from '../layout/layout-simple.svelte.js';
import { getColorCode } from '../../utils/bun-color.mjs';
import * as ANSI from '../../utils/ansi-codes.mjs';
import { BORDERS as BORDER_STYLES } from '../../utils/borders.mjs';

class FrameBuffer {
	cells;
	width;
	height;

	constructor(width, height) {
		this.width = width;
		this.height = height;
		this.cells = new Array(width * height);
		this.clear();
	}

	clear() {
		const defaultCell = { char: " ", fg: undefined, bg: undefined, style: 0 };

		for (let i = 0; i < this.cells.length; i++) {
			this.cells[i] = { ...defaultCell };
		}
	}

	setCell(x, y, cell, clipRect) {
		if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;

		if (clipRect) {
			if (x < clipRect.x || x >= clipRect.x + clipRect.width) return;
			if (y < clipRect.y || y >= clipRect.y + clipRect.height) return;
		}

		Object.assign(this.cells[y * this.width + x], cell);
	}

	getCell(x, y) {
		if (x < 0 || x >= this.width || y < 0 || y >= this.height) return null;

		return this.cells[y * this.width + x];
	}
}

function getBorderSet(style) {
	const borderMap = [
		null,
		BORDER_STYLES.single,
		BORDER_STYLES.double,
		BORDER_STYLES.rounded,
		BORDER_STYLES.heavy,
		BORDER_STYLES.dashed,
		BORDER_STYLES.dotted,
		BORDER_STYLES.ascii,
		BORDER_STYLES.block,
		BORDER_STYLES.mixedDoubleH,
		BORDER_STYLES.mixedDoubleV
	];

	return borderMap[style] || null;
}

function renderBorder(buffer, x, y, width, height, style, color, clipRect) {
	if (style < 1 || style > 10) return;

	const borderSet = getBorderSet(style);

	if (!borderSet) return;

	for (let dx = 1; dx < width - 1; dx++) {
		buffer.setCell(x + dx, y, { char: String.fromCharCode(borderSet.horizontal), fg: color }, clipRect);
		buffer.setCell(x + dx, y + height - 1, { char: String.fromCharCode(borderSet.horizontal), fg: color }, clipRect);
	}

	for (let dy = 1; dy < height - 1; dy++) {
		buffer.setCell(x, y + dy, { char: String.fromCharCode(borderSet.vertical), fg: color }, clipRect);
		buffer.setCell(x + width - 1, y + dy, { char: String.fromCharCode(borderSet.vertical), fg: color }, clipRect);
	}

	buffer.setCell(x, y, { char: String.fromCharCode(borderSet.topLeft), fg: color }, clipRect);
	buffer.setCell(x + width - 1, y, { char: String.fromCharCode(borderSet.topRight), fg: color }, clipRect);
	buffer.setCell(x, y + height - 1, { char: String.fromCharCode(borderSet.bottomLeft), fg: color }, clipRect);
	buffer.setCell(x + width - 1, y + height - 1, { char: String.fromCharCode(borderSet.bottomRight), fg: color }, clipRect);
}

function intersectClipRects(a, b) {
	const x = Math.max(a.x, b.x);
	const y = Math.max(a.y, b.y);
	const right = Math.min(a.x + a.width, b.x + b.width);
	const bottom = Math.min(a.y + a.height, b.y + b.height);

	if (right <= x || bottom <= y) return null;

	return { x, y, width: right - x, height: bottom - y };
}

function getContentClipRect(index, parentClip) {
	const x = computedX[index] || 0;
	const y = computedY[index] || 0;
	const width = computedWidth[index] || 0;
	const height = computedHeight[index] || 0;
	const borderStyle = borderStyles[index] || 0;
	const hasBorder = borderStyle > 0;
	const contentX = hasBorder ? x + 1 : x;
	const contentY = hasBorder ? y + 1 : y;
	const contentWidth = hasBorder ? Math.max(0, width - 2) : width;
	const contentHeight = hasBorder ? Math.max(0, height - 2) : height;

	const componentClip = {
		x: contentX,
		y: contentY,
		width: contentWidth,
		height: contentHeight
	};

	if (parentClip) {
		return intersectClipRects(componentClip, parentClip);
	}

	return componentClip;
}

function renderComponent(
	buffer,
	index,
	parentClip,
	parentScrollY = 0,
	parentScrollX = 0
) {
	if (!visibility[index]) return;

	const x = (computedX[index] || 0) - parentScrollX;
	const y = (computedY[index] || 0) - parentScrollY;
	const width = computedWidth[index] || 0;
	const height = computedHeight[index] || 0;

	if (width <= 0 || height <= 0) return;

	const componentBounds = { x, y, width, height };

	if (parentClip) {
		const intersection = intersectClipRects(componentBounds, parentClip);

		if (!intersection) return;
	}

	const fgColor = colors[index * 2];
	const bgColor = colors[index * 2 + 1];
	const textStyle = textStyles[index] || 0;
	const borderStyle = borderStyles[index] || 0;
	const yOffset = scrollable[index] && $.strict_equals(componentType[index], ComponentType.BOX) ? scrollOffset[index] || 0 : 0;
	const xOffset = scrollable[index] && $.strict_equals(componentType[index], ComponentType.BOX) ? scrollOffsetX[index] || 0 : 0;

	if ($.strict_equals(bgColor, undefined, false)) {
		for (let dy = 0; dy < height; dy++) {
			for (let dx = 0; dx < width; dx++) {
				buffer.setCell(x + dx, y + dy, { bg: bgColor }, parentClip);
			}
		}
	}

	const borderColor = borderColors[index] ?? fgColor;
	const topStyle = borderTop[index] || borderStyle;
	const bottomStyle = borderBottom[index] || borderStyle;
	const leftStyle = borderLeft[index] || borderStyle;
	const rightStyle = borderRight[index] || borderStyle;

	if (topStyle > 0) {
		const borderSet = getBorderSet(topStyle);

		if (borderSet) {
			for (let dx = 1; dx < width - 1; dx++) {
				buffer.setCell(
					x + dx,
					y,
					{
						char: String.fromCharCode(borderSet.horizontal),
						fg: borderColor
					},
					parentClip
				);
			}
		}
	}

	if (bottomStyle > 0) {
		const borderSet = getBorderSet(bottomStyle);

		if (borderSet) {
			for (let dx = 1; dx < width - 1; dx++) {
				buffer.setCell(
					x + dx,
					y + height - 1,
					{
						char: String.fromCharCode(borderSet.horizontal),
						fg: borderColor
					},
					parentClip
				);
			}
		}
	}

	if (leftStyle > 0) {
		const borderSet = getBorderSet(leftStyle);

		if (borderSet) {
			for (let dy = 1; dy < height - 1; dy++) {
				buffer.setCell(
					x,
					y + dy,
					{
						char: String.fromCharCode(borderSet.vertical),
						fg: borderColor
					},
					parentClip
				);
			}
		}
	}

	if (rightStyle > 0) {
		const borderSet = getBorderSet(rightStyle);

		if (borderSet) {
			for (let dy = 1; dy < height - 1; dy++) {
				buffer.setCell(
					x + width - 1,
					y + dy,
					{
						char: String.fromCharCode(borderSet.vertical),
						fg: borderColor
					},
					parentClip
				);
			}
		}
	}

	if (topStyle > 0 || leftStyle > 0) {
		const cornerStyle = topStyle || leftStyle;
		const borderSet = getBorderSet(cornerStyle);

		if (borderSet) {
			buffer.setCell(
				x,
				y,
				{
					char: String.fromCharCode(borderSet.topLeft),
					fg: borderColor
				},
				parentClip
			);
		}
	}

	if (topStyle > 0 || rightStyle > 0) {
		const cornerStyle = topStyle || rightStyle;
		const borderSet = getBorderSet(cornerStyle);

		if (borderSet) {
			buffer.setCell(
				x + width - 1,
				y,
				{
					char: String.fromCharCode(borderSet.topRight),
					fg: borderColor
				},
				parentClip
			);
		}
	}

	if (bottomStyle > 0 || leftStyle > 0) {
		const cornerStyle = bottomStyle || leftStyle;
		const borderSet = getBorderSet(cornerStyle);

		if (borderSet) {
			buffer.setCell(
				x,
				y + height - 1,
				{
					char: String.fromCharCode(borderSet.bottomLeft),
					fg: borderColor
				},
				parentClip
			);
		}
	}

	if (bottomStyle > 0 || rightStyle > 0) {
		const cornerStyle = bottomStyle || rightStyle;
		const borderSet = getBorderSet(cornerStyle);

		if (borderSet) {
			buffer.setCell(
				x + width - 1,
				y + height - 1,
				{
					char: String.fromCharCode(borderSet.bottomRight),
					fg: borderColor
				},
				parentClip
			);
		}
	}

	const adjustedClipRect = {
		x: x + (borderStyle > 0 ? 1 : 0),
		y: y + (borderStyle > 0 ? 1 : 0),
		width: width - (borderStyle > 0 ? 2 : 0),
		height: height - (borderStyle > 0 ? 2 : 0)
	};

	const contentClip = parentClip
		? intersectClipRects(adjustedClipRect, parentClip)
		: adjustedClipRect;

	if ($.strict_equals(componentType[index], ComponentType.TEXT)) {
		if (!contentClip) return;

		const lines = wrappedLines[index] || [];
		const contentX = borderStyle > 0 ? x + 1 : x;
		const contentY = borderStyle > 0 ? y + 1 : y;
		const contentWidth = borderStyle > 0 ? width - 2 : width;
		const contentHeight = borderStyle > 0 ? height - 2 : height;

		for (let lineIdx = 0; lineIdx < lines.length && lineIdx < contentHeight; lineIdx++) {
			const line = lines[lineIdx];
			const py = contentY + lineIdx;

			if (py < contentClip.y || py >= contentClip.y + contentClip.height) continue;

			const visibleLine = line;

			for (let charIdx = 0; visibleLine && charIdx < visibleLine.length && charIdx < contentWidth; charIdx++) {
				const cellX = contentX + charIdx;

				buffer.setCell(cellX, py, { char: visibleLine[charIdx], fg: fgColor, style: textStyle }, contentClip);
			}
		}

		if ($.strict_equals(focus.value, index) && $.strict_equals(cursorPosition[index], undefined, false)) {
			const pos = cursorPosition[index];
		}
	}

	if ($.strict_equals(componentType[index], ComponentType.BOX)) {
		if (!contentClip) return;

		const children = childIndices[index] || [];
		const childScrollY = parentScrollY + yOffset;
		const childScrollX = parentScrollX + xOffset;

		for (const childIndex of children) {
			renderComponent(buffer, childIndex, contentClip, childScrollY, childScrollX);
		}
	}
}

const frameBuffer = $.tag(
	$.derived(() => {
		const renderHeight = contentHeight.value;
		const buffer = new FrameBuffer(terminalSize.width, renderHeight);
		const engine = getEngine();
		const sortedComponents = engine().visibleComponentsSorted;

		for (const index of sortedComponents) {
			if (!parentIndex[index] || $.strict_equals(parentIndex[index], -1)) {
				renderComponent(buffer, index, undefined, 0, 0);
			}
		}

		return buffer;
	}),
	'frameBuffer'
);

function generateDiff(prev, next) {
	const parts = [];
	let lastFg = undefined;
	let lastBg = undefined;
	let lastStyle = 0;
	let lastY = -1;
	let lastX = -1;
	const isFullscreen = terminalSize.fullscreen;
	const sizeChanged = prev && ($.strict_equals(prev.width, next.width, false) || $.strict_equals(prev.height, next.height, false));

	if (sizeChanged && !isFullscreen) {
		if (prev && (prev.height > next.height || prev.width > next.width)) {
			for (let y = next.height; y < prev.height; y++) {
				parts.push(ANSI.moveTo(1, y + 1));
				parts.push(ANSI.CLEAR_LINE);
			}

			parts.push(ANSI.RESTORE_CURSOR);
		}

		prev = null;
	}

	const height = isFullscreen
		? Math.min(next.height, terminalSize.height)
		: next.height;

	for (let y = 0; y < height; y++) {
		for (let x = 0; x < next.width; x++) {
			const newCell = next.getCell(x, y);
			const oldCell = prev?.getCell(x, y);

			if (oldCell && $.strict_equals(oldCell.char, newCell.char) && $.strict_equals(oldCell.fg, newCell.fg) && $.strict_equals(oldCell.bg, newCell.bg) && $.strict_equals(oldCell.style, newCell.style)) {
				continue;
			}

			if ($.strict_equals(lastY, y, false) || $.strict_equals(lastX, x - 1, false)) {
				parts.push(ANSI.moveTo(x + 1, y + 1));
				lastY = y;
				lastX = x;
			} else {
				lastX = x;
			}

			if ($.strict_equals(newCell.style, lastStyle, false)) {
				parts.push(ANSI.RESET);

				if (newCell.style & 1) parts.push(ANSI.BOLD);
				if (newCell.style & 2) parts.push(ANSI.ITALIC);
				if (newCell.style & 4) parts.push(ANSI.UNDERLINE);
				if (newCell.style & 8) parts.push(ANSI.STRIKETHROUGH);
				if (newCell.style & 16) parts.push(ANSI.DIM);
				if (newCell.style & 32) parts.push(ANSI.BLINK);
				if (newCell.style & 64) parts.push(ANSI.REVERSE);
				if (newCell.style & 128) parts.push(ANSI.HIDDEN);

				lastStyle = newCell.style;
				lastFg = undefined;
				lastBg = undefined;
			}

			if ($.strict_equals(newCell.fg, lastFg, false)) {
				parts.push(getColorCode(newCell.fg, false));
				lastFg = newCell.fg;
			}

			if ($.strict_equals(newCell.bg, lastBg, false)) {
				parts.push(getColorCode(newCell.bg, true));
				lastBg = newCell.bg;
			}

			parts.push(newCell.char);
		}
	}

	return parts.join("");
}

let previousBuffer = null;
let isFirstRender = true;

export function initializeRenderer() {
	if (!terminalSize.fullscreen) {
		process.stdout.write(ANSI.SAVE_CURSOR);
	}

	$.user_effect(() => {
		const nextBuffer = $.get(frameBuffer);

		if (!terminalSize.fullscreen && !isFirstRender) {
			process.stdout.write(ANSI.RESTORE_CURSOR);
		}

		const diff = generateDiff(previousBuffer, nextBuffer);

		if (diff) {
			process.stdout.write(diff);
		}

		previousBuffer = nextBuffer;
		isFirstRender = false;
	});

	return () => {
		process.stdout.write(ANSI.RESET);

		if (!terminalSize.fullscreen) {
			process.stdout.write(ANSI.RESTORE_CURSOR);
		}

		previousBuffer = null;
		isFirstRender = true;
	};
}