/* engine.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';
import { SvelteMap } from "svelte/reactivity";
import { Yoga } from '../layout/yoga-instance.mjs';
import { HitGrid, MouseEventDispatcher } from '../../input/mouse.mjs';

export const ComponentType = { TEXT: 0, BOX: 1 };

export const registry = $.tag_proxy(
	$.proxy({
		idToIndex: new SvelteMap(),
		indexToId: new SvelteMap(),
		allocatedIndices: new Set(),
		freeIndices: [],
		nextIndex: 0
	}),
	'registry'
);

export const terminalSize = $.tag_proxy($.proxy({ width: 80, height: 24, fullscreen: false }), 'terminalSize');
export const componentType = $.tag_proxy($.proxy([]), 'componentType');
export const visibility = $.tag_proxy($.proxy([]), 'visibility');
export const zIndex = $.tag_proxy($.proxy([]), 'zIndex');
export const opacity = $.tag_proxy($.proxy([]), 'opacity');
export const parentIndex = $.tag_proxy($.proxy([]), 'parentIndex');
export const childIndices = $.tag_proxy($.proxy([]), 'childIndices');
export const depth = $.tag_proxy($.proxy([]), 'depth');
export const texts = $.tag_proxy($.proxy([]), 'texts');
export const wrappedLines = $.tag_proxy($.proxy([]), 'wrappedLines');
export const layoutProps = $.tag_proxy($.proxy([]), 'layoutProps');
export const colors = $.tag_proxy($.proxy([]), 'colors');
export const textStyles = $.tag_proxy($.proxy([]), 'textStyles');
export const borderStyles = $.tag_proxy($.proxy([]), 'borderStyles');
export const borderColors = $.tag_proxy($.proxy([]), 'borderColors');
export const borderTop = $.tag_proxy($.proxy([]), 'borderTop');
export const borderBottom = $.tag_proxy($.proxy([]), 'borderBottom');
export const borderLeft = $.tag_proxy($.proxy([]), 'borderLeft');
export const borderRight = $.tag_proxy($.proxy([]), 'borderRight');
export const scrollable = $.tag_proxy($.proxy([]), 'scrollable');
export const scrollOffset = $.tag_proxy($.proxy([]), 'scrollOffset');
export const scrollOffsetX = $.tag_proxy($.proxy([]), 'scrollOffsetX');
export const maxScrollOffset = $.tag_proxy($.proxy([]), 'maxScrollOffset');
export const maxScrollOffsetX = $.tag_proxy($.proxy([]), 'maxScrollOffsetX');
export const focusable = $.tag_proxy($.proxy([]), 'focusable');
export const tabIndex = $.tag_proxy($.proxy([]), 'tabIndex');
export const focus = $.tag_proxy($.proxy({ value: -1 }), 'focus');
export const cursorPosition = $.tag_proxy($.proxy([]), 'cursorPosition');
export const selectionStart = $.tag_proxy($.proxy([]), 'selectionStart');
export const selectionEnd = $.tag_proxy($.proxy([]), 'selectionEnd');
export const mouseHandlers = $.tag_proxy($.proxy([]), 'mouseHandlers');
export const hovered = $.tag_proxy($.proxy([]), 'hovered');
export const pressed = $.tag_proxy($.proxy([]), 'pressed');
export const hitGrid = $.tag_proxy($.proxy(new HitGrid(80, 24)), 'hitGrid');
export const mouseDispatcher = $.tag_proxy($.proxy(new MouseEventDispatcher(80, 24)), 'mouseDispatcher');
export const computedX = $.tag_proxy($.proxy([]), 'computedX');
export const computedY = $.tag_proxy($.proxy([]), 'computedY');
export const computedWidth = $.tag_proxy($.proxy([]), 'computedWidth');
export const computedHeight = $.tag_proxy($.proxy([]), 'computedHeight');
export const yogaNodes = $.tag_proxy($.proxy([]), 'yogaNodes');

export function allocateIndex(id) {
	const existing = registry.idToIndex.get(id);

	if ($.strict_equals(existing, undefined, false)) return existing;

	let index;

	if (registry.freeIndices.length > 0) {
		index = registry.freeIndices.pop();
	} else {
		index = registry.nextIndex++;
	}

	registry.idToIndex.set(id, index);
	registry.indexToId.set(index, id);
	registry.allocatedIndices.add(index);

	if (!yogaNodes[index]) {
		yogaNodes[index] = Yoga.Node.create();
	}

	return index;
}

export function releaseIndex(id) {
	const index = registry.idToIndex.get(id);

	if ($.strict_equals(index, undefined)) return;

	registry.idToIndex.delete(id);
	registry.indexToId.delete(index);
	registry.allocatedIndices.delete(index);
	registry.freeIndices.push(index);
	componentType[index] = 0;
	visibility[index] = false;
	zIndex[index] = 0;
	opacity[index] = 100;
	parentIndex[index] = -1;
	childIndices[index] = [];
	depth[index] = 0;
	texts[index] = "";
	wrappedLines[index] = [];
	layoutProps[index] = null;
	colors[index * 2] = undefined;
	colors[index * 2 + 1] = undefined;
	textStyles[index] = 0;
	borderStyles[index] = 0;
	borderColors[index] = undefined;
	borderTop[index] = 0;
	borderBottom[index] = 0;
	borderLeft[index] = 0;
	borderRight[index] = 0;
	scrollable[index] = false;
	scrollOffset[index] = 0;
	scrollOffsetX[index] = 0;
	maxScrollOffset[index] = 0;
	maxScrollOffsetX[index] = 0;
	focusable[index] = false;
	tabIndex[index] = -1;
	cursorPosition[index] = 0;
	selectionStart[index] = -1;
	selectionEnd[index] = -1;
	mouseHandlers[index] = null;
	hovered[index] = false;
	pressed[index] = false;
	mouseDispatcher.removeHandlers(index);
	computedX[index] = 0;
	computedY[index] = 0;
	computedWidth[index] = 0;
	computedHeight[index] = 0;

	if (yogaNodes[index]) {
		yogaNodes[index].free();
		yogaNodes[index] = null;
	}
}

export function setTerminalSize(width, height) {
	terminalSize.width = width;
	terminalSize.height = height;
	hitGrid.resize(width, height);
	mouseDispatcher.resize(width, height);
}

export function getEngine() {
	const visibleComponentsSorted = $.tag(
		$.derived(() => {
			const visible = [];

			for (let i = 0; i < registry.nextIndex; i++) {
				if (registry.allocatedIndices.has(i) && visibility[i]) {
					visible.push(i);
				}
			}

			visible.sort((a, b) => (zIndex[a] || 0) - (zIndex[b] || 0));

			return visible;
		}),
		'visibleComponentsSorted'
	);

	const nextFocusableIndex = $.tag(
		$.derived(() => {
			const start = focus.value;

			for (let i = start + 1; i < registry.nextIndex; i++) {
				if (registry.allocatedIndices.has(i) && focusable[i] && visibility[i]) {
					return i;
				}
			}

			for (let i = 0; i <= start; i++) {
				if (registry.allocatedIndices.has(i) && focusable[i] && visibility[i]) {
					return i;
				}
			}

			return -1;
		}),
		'nextFocusableIndex'
	);

	const previousFocusableIndex = $.tag(
		$.derived(() => {
			const start = focus.value;

			for (let i = start - 1; i >= 0; i--) {
				if (registry.allocatedIndices.has(i) && focusable[i] && visibility[i]) {
					return i;
				}
			}

			for (let i = registry.nextIndex - 1; i >= start; i--) {
				if (registry.allocatedIndices.has(i) && focusable[i] && visibility[i]) {
					return i;
				}
			}

			return -1;
		}),
		'previousFocusableIndex'
	);

	return () => ({
		visibleComponentsSorted: $.get(visibleComponentsSorted),
		nextFocusableIndex: $.get(nextFocusableIndex),
		previousFocusableIndex: $.get(previousFocusableIndex)
	});
}