/* layout.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';

import {
	visibility,
	borderStyles,
	childIndices,
	componentType,
	ComponentType,
	computedHeight,
	computedWidth,
	computedX,
	computedY,
	layoutProps,
	parentIndex,
	registry,
	scrollable,
	terminalSize,
	texts,
	wrappedLines,
	yogaNodes,
	maxScrollOffset,
	maxScrollOffsetX,
	focus,
	focusable
} from '../state/engine.svelte.js';

import {
	getAbsolutePosition,
	getComputedDimensions,
	getChildIndices,
	getParentIndex
} from './yoga-helpers.mjs';

import { Yoga } from './yoga-instance.mjs';
import { wrapText, measureText } from '../../utils/text-wrap.mjs';
import { applyYogaProps } from './yoga-props.mjs';

export function initializeYogaNode(index, type) {
	const node = yogaNodes[index];

	if (!node) return;

	if ($.strict_equals(type, ComponentType.TEXT)) {
		node.setMeasureFunc((width, widthMode, height, heightMode) => {
			const text = texts[index] || "";

			const lines = text.split(`
`);

			const naturalWidth = Math.max(...lines.map((l) => measureText(l)), 1);
			const naturalHeight = Math.max(lines.length, 1);

			return { width: naturalWidth, height: naturalHeight };
		});
	}
}

function updateYogaNodeProps(index) {
	const node = yogaNodes[index];

	if (!node) return;

	const props = layoutProps[index] || {};
	const parentIdx = parentIndex[index];
	const isRoot = parentIdx ? parentIdx < 0 : false;

	const context = {
		componentType: componentType[index],
		parentProps: parentIdx && (parentIdx >= 0 ? layoutProps[parentIdx] : undefined),
		isRoot
	};

	node.setAlwaysFormsContainingBlock(true);
	applyYogaProps(node, props, Yoga, context);

	if (!props.borderWidth && borderStyles[index] && borderStyles[index] > 0) {
		node.setBorder(Yoga.EDGE_ALL, 1);
	}
}

function calculateAndUpdateLayout() {
	for (let i = 0; i < registry.nextIndex; i++) {
		if (!registry.allocatedIndices.has(i)) continue;

		updateYogaNodeProps(i);
	}

	for (let i = 0; i < registry.nextIndex; i++) {
		if (!registry.allocatedIndices.has(i)) continue;

		const parentIdx = parentIndex[i];

		if (parentIdx && parentIdx >= 0) continue;

		const rootNode = yogaNodes[i];

		if (!rootNode) continue;

		rootNode.calculateLayout(terminalSize.width, terminalSize.height, Yoga.DIRECTION_LTR);
	}

	let maxContentHeight = 0;

	for (let i = 0; i < registry.nextIndex; i++) {
		if (!registry.allocatedIndices.has(i)) continue;

		const node = yogaNodes[i];

		if (!node) continue;

		const layout = node.getComputedLayout();
		const position = getAbsolutePosition(i);

		computedX[i] = position.x;
		computedY[i] = position.y;
		computedWidth[i] = Math.round(layout.width);
		computedHeight[i] = Math.round(layout.height);

		if (i < 5) {
			console.log(`Component ${i}: pos(${position.x},${position.y}) size(${Math.round(layout.width)}x${Math.round(layout.height)})`);
		}

		const parentIdx = parentIndex[i];

		if (parentIdx && parentIdx < 0 && visibility[i]) {
			const bottom = computedY[i] + computedHeight[i];

			maxContentHeight = Math.max(maxContentHeight, bottom);
		}

		if ($.strict_equals(componentType[i], ComponentType.TEXT)) {
			const text = texts[i] || "";
			const parentIdx = parentIndex[i];
			let wrapWidth = 80;

			if ($.strict_equals(parentIdx, undefined, false) && parentIdx >= 0) {
				const parentNode = yogaNodes[parentIdx];

				if (parentNode) {
					const parentPaddingLeft = parentNode.getComputedPadding(Yoga.EDGE_LEFT);
					const parentPaddingRight = parentNode.getComputedPadding(Yoga.EDGE_RIGHT);
					const parentBorderLeft = parentNode.getComputedBorder(Yoga.EDGE_LEFT);
					const parentBorderRight = parentNode.getComputedBorder(Yoga.EDGE_RIGHT);

					wrapWidth = parentNode.getComputedWidth() - parentPaddingLeft - parentPaddingRight - parentBorderLeft - parentBorderRight;
				}
			}

			const wrapped = wrapText(text, Math.floor(Math.max(1, wrapWidth)));

			wrappedLines[i] = wrapped;
			maxScrollOffset[i] = 0;
			maxScrollOffsetX[i] = 0;
		} else if ($.strict_equals(componentType[i], ComponentType.BOX)) {
			wrappedLines[i] = [];

			const children = getChildIndices(i);

			if (children.length > 0) {
				let maxChildBottom = 0;
				let maxChildRight = 0;

				for (const childIdx of children) {
					if (!visibility[childIdx]) continue;

					const childNode = yogaNodes[childIdx];

					if (childNode) {
						const childBottom = childNode.getComputedTop() + childNode.getComputedHeight();
						const childRight = childNode.getComputedLeft() + childNode.getComputedWidth();

						maxChildBottom = Math.max(maxChildBottom, childBottom);
						maxChildRight = Math.max(maxChildRight, childRight);
					}
				}

				const boxHeight = computedHeight[i];
				const boxWidth = computedWidth[i];
				const userProps = layoutProps[i];

				if (boxHeight && maxChildBottom > boxHeight) {
					maxScrollOffset[i] = Math.ceil(maxChildBottom - boxHeight);

					if (!userProps?.overflow || $.strict_equals(userProps.overflow, "auto")) {
						scrollable[i] = true;
						focusable[i] = true;
					}
				} else {
					maxScrollOffset[i] = 0;
				}

				if (boxWidth && maxChildRight > boxWidth) {
					maxScrollOffsetX[i] = Math.ceil(maxChildRight - boxWidth);

					if (!userProps?.overflow || $.strict_equals(userProps.overflow, "auto")) {
						scrollable[i] = true;
						focusable[i] = true;
					}
				} else {
					maxScrollOffsetX[i] = 0;
				}
			} else {
				maxScrollOffset[i] = 0;
				maxScrollOffsetX[i] = 0;
			}
		} else {
			wrappedLines[i] = [];
			maxScrollOffset[i] = 0;
			maxScrollOffsetX[i] = 0;
		}
	}

	contentHeight.value = terminalSize.fullscreen ? terminalSize.height : Math.max(maxContentHeight, 1);
}

export const contentHeight = $.tag_proxy($.proxy({ value: 0 }), 'contentHeight');

export function initializeLayout() {
	$.user_effect(() => {
		calculateAndUpdateLayout();
	});

	return () => {};
}