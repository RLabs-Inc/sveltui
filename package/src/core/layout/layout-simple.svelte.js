/* layout-simple.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';

import {
	visibility,
	borderStyles,
	componentType,
	ComponentType,
	computedHeight,
	computedWidth,
	computedX,
	computedY,
	layoutProps,
	parentIndex,
	registry,
	scrollable,
	terminalSize,
	texts,
	wrappedLines,
	yogaNodes,
	maxScrollOffset,
	focusable
} from '../state/engine.svelte.js';

import { Yoga } from './yoga-instance.mjs';
import { applyTerminalProps } from './yoga-props-simple.mjs';

function measureText(text) {
	const lines = text.split(`
`);

	return {
		width: Math.max(...lines.map((line) => line.length), 1),
		height: Math.max(lines.length, 1)
	};
}

function wrapText(text, maxWidth) {
	if (maxWidth <= 0) return [text];

	const words = text.split(" ");
	const lines = [];
	let currentLine = "";

	for (const word of words) {
		if (word.includes(`
`)) {
			const parts = word.split(`
`);

			for (let i = 0; i < parts.length; i++) {
				if (i > 0) {
					lines.push(currentLine);
					currentLine = "";
				}

				currentLine += (currentLine ? " " : "") + parts[i];
			}
		} else if ((currentLine + " " + word).length <= maxWidth) {
			currentLine += (currentLine ? " " : "") + word;
		} else {
			if (currentLine) lines.push(currentLine);

			currentLine = word;
		}
	}

	if (currentLine) lines.push(currentLine);

	return lines.length > 0 ? lines : [""];
}

export function setupYogaNode(index) {
	const node = yogaNodes[index];

	if (!node) return;

	const type = componentType[index];

	if ($.strict_equals(type, ComponentType.TEXT)) {
		node.setMeasureFunc((width, widthMode, height, heightMode) => {
			const text = texts[index] || "";
			const { width: textWidth, height: textHeight } = measureText(text);

			if (width && width < textWidth) {
				const wrapped = wrapText(text, Math.floor(width));

				return { width: Math.min(textWidth, width), height: wrapped.length };
			}

			return { width: textWidth, height: textHeight };
		});
	}
}

function calculateLayout() {
	for (let i = 0; i < registry.nextIndex; i++) {
		if (!registry.allocatedIndices.has(i)) continue;

		const node = yogaNodes[i];

		if (!node) continue;

		const props = layoutProps[i] || {};

		applyTerminalProps(node, props, Yoga);

		if (!props.borderWidth && borderStyles[i] && borderStyles[i] > 0) {
			node.setBorder(Yoga.EDGE_ALL, 1);
		}
	}

	for (let i = 0; i < registry.nextIndex; i++) {
		if (!registry.allocatedIndices.has(i)) continue;

		const parentIdx = parentIndex[i];

		if ($.strict_equals(parentIdx, undefined) || parentIdx >= 0) continue;

		const rootNode = yogaNodes[i];

		if (!rootNode) continue;

		rootNode.calculateLayout(terminalSize.width, terminalSize.fullscreen ? terminalSize.height : undefined, Yoga.DIRECTION_LTR);
	}

	for (let i = 0; i < registry.nextIndex; i++) {
		if (!registry.allocatedIndices.has(i)) continue;

		const node = yogaNodes[i];

		if (!node) continue;

		let x = Math.round(node.getComputedLeft());
		let y = Math.round(node.getComputedTop());
		let current = node.getParent();

		while (current) {
			x += Math.round(current.getComputedLeft());
			y += Math.round(current.getComputedTop());
			current = current.getParent();
		}

		computedX[i] = x;
		computedY[i] = y;
		computedWidth[i] = Math.round(node.getComputedWidth());
		computedHeight[i] = Math.round(node.getComputedHeight());

		if ($.strict_equals(componentType[i], ComponentType.TEXT)) {
			const text = texts[i] || "";
			const width = computedWidth[i] || 80;

			wrappedLines[i] = wrapText(text, width);
		} else {
			wrappedLines[i] = [];
		}

		if ($.strict_equals(componentType[i], ComponentType.BOX)) {
			let maxChildBottom = 0;
			const childCount = node.getChildCount();

			for (let c = 0; c < childCount; c++) {
				const child = node.getChild(c);

				if (child) {
					const childBottom = child.getComputedTop() + child.getComputedHeight();

					maxChildBottom = Math.max(maxChildBottom, childBottom);
				}
			}

			const boxHeight = computedHeight[i] || 0;

			if (maxChildBottom > boxHeight) {
				maxScrollOffset[i] = Math.ceil(maxChildBottom - boxHeight);

				const props = layoutProps[i];

				if (!props?.overflow || $.strict_equals(props.overflow, "scroll")) {
					scrollable[i] = true;
					focusable[i] = true;
				}
			} else {
				maxScrollOffset[i] = 0;
			}
		}
	}

	if (terminalSize.fullscreen) {
		contentHeight.value = terminalSize.height;
	} else {
		let maxBottom = 0;

		for (let i = 0; i < registry.nextIndex; i++) {
			if (!registry.allocatedIndices.has(i)) continue;
			if (!visibility[i]) continue;

			const bottom = (computedY[i] || 0) + (computedHeight[i] || 0);

			maxBottom = Math.max(maxBottom, bottom);
		}

		contentHeight.value = Math.max(maxBottom, 1);
	}
}

export const contentHeight = $.tag_proxy($.proxy({ value: 0 }), 'contentHeight');

export function initializeSimpleLayout() {
	$.user_effect(() => {
		calculateLayout();
	});

	return () => {};
}