/* base-component.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';

import {
	allocateIndex,
	componentType,
	focusable,
	layoutProps,
	mouseDispatcher,
	mouseHandlers,
	releaseIndex,
	tabIndex,
	visibility,
	yogaNodes
} from '../core/state/engine.svelte.js';

import { applyYogaProps } from '../core/layout/yoga-props.mjs';
import { Yoga } from '../core/layout/yoga-instance.mjs';
import { setupComponent, cleanupComponent } from '../utils/hierarchy.svelte.js';
import { initializeYogaNode } from '../core/layout/layout.svelte.js';
import { parentIndex } from '../core/state/engine.svelte.js';
import { keyboard } from '../input/keyboard.svelte.js';
import { onMount, onDestroy } from "svelte";

export class BaseComponent {
	id;
	index;
	props;
	canHaveChildren;
	keyboardUnsubscribe = null;

	constructor(type, props, canHaveChildren = false) {
		this.id = `component-${Math.random().toString(36).substr(2, 9)}`;
		this.index = allocateIndex(this.id);
		this.props = props;
		this.canHaveChildren = canHaveChildren;
		componentType[this.index] = type;
		visibility[this.index] = true;
		setupComponent(this.index, canHaveChildren);
		initializeYogaNode(this.index, type);

		if (props.focusable) {
			focusable[this.index] = true;
			tabIndex[this.index] = props.tabIndex ?? 0;
		}

		this.setupMouseHandlers();
		this.setupKeyboardHandlers();
		this.updateLayoutProps();
	}

	updateLayoutProps() {
		layoutProps[this.index] = this.props;

		const node = yogaNodes[this.index];

		if (node) {
			const parentIdx = parentIndex[this.index];

			const context = {
				componentType: componentType[this.index],
				parentProps: parentIdx && parentIdx >= 0 ? layoutProps[parentIdx] : undefined,
				isRoot: parentIdx && parentIdx < 0 ? true : false
			};

			applyYogaProps(node, this.props, Yoga, context);
		}
	}

	setupMouseHandlers() {
		const { props } = this;
		const hasMouseHandlers = !!(props.onClick || props.onMouseDown || props.onMouseUp || props.onMouseEnter || props.onMouseLeave || props.onMouseMove || props.onWheel);

		if (!hasMouseHandlers) return;

		const handlers = {};

		if (props.onClick) {
			handlers.onClick = (event) => {
				props.onClick(event);

				return true;
			};
		}

		if (props.onMouseDown) {
			handlers.onMouseDown = (event) => {
				props.onMouseDown(event);

				return true;
			};
		}

		if (props.onMouseUp) {
			handlers.onMouseUp = (event) => {
				props.onMouseUp(event);

				return true;
			};
		}

		if (props.onMouseEnter) {
			handlers.onMouseEnter = (event) => {
				props.onMouseEnter(event);

				return true;
			};
		}

		if (props.onMouseLeave) {
			handlers.onMouseLeave = (event) => {
				props.onMouseLeave(event);

				return true;
			};
		}

		if (props.onMouseMove) {
			handlers.onMouseMove = (event) => {
				props.onMouseMove(event);

				return true;
			};
		}

		if (props.onWheel) {
			handlers.onWheel = (event) => {
				props.onWheel(event);

				return true;
			};
		}

		mouseHandlers[this.index] = handlers;
		mouseDispatcher.setHandlers(this.index, handlers);
	}

	setupKeyboardHandlers() {
		const { props } = this;
		const hasKeyboardHandlers = !!(props.onKeyPress || props.onEnter || props.onEscape || props.onSpace || props.onArrowUp || props.onArrowDown || props.onArrowLeft || props.onArrowRight);

		if (!hasKeyboardHandlers) return;

		if (this.keyboardUnsubscribe) {
			this.keyboardUnsubscribe();
			this.keyboardUnsubscribe = null;
		}

		this.keyboardUnsubscribe = keyboard.onFocused(this.index, (event) => {
			switch (event.key) {
				case "Enter":
					if (props.onEnter) {
						props.onEnter();

						return true;
					}
					break;

				case "Escape":
					if (props.onEscape) {
						props.onEscape();

						return true;
					}
					break;

				case " ":

				case "Space":
					if (props.onSpace) {
						props.onSpace();

						return true;
					}
					break;

				case "ArrowUp":
					if (props.onArrowUp) {
						props.onArrowUp();

						return true;
					}
					break;

				case "ArrowDown":
					if (props.onArrowDown) {
						props.onArrowDown();

						return true;
					}
					break;

				case "ArrowLeft":
					if (props.onArrowLeft) {
						props.onArrowLeft();

						return true;
					}
					break;

				case "ArrowRight":
					if (props.onArrowRight) {
						props.onArrowRight();

						return true;
					}
					break;
			}

			if (props.onKeyPress) {
				return props.onKeyPress(event);
			}

			return false;
		});
	}

	updateProps(newProps) {
		this.props = { ...this.props, ...newProps };
		this.updateLayoutProps();

		if ("onClick" in newProps || "onMouseDown" in newProps || "onMouseUp" in newProps || "onMouseEnter" in newProps || "onMouseLeave" in newProps || "onMouseMove" in newProps || "onWheel" in newProps) {
			mouseDispatcher.removeHandlers(this.index);
			mouseHandlers[this.index] = null;
			this.setupMouseHandlers();
		}

		if ("onKeyPress" in newProps || "onEnter" in newProps || "onEscape" in newProps || "onSpace" in newProps || "onArrowUp" in newProps || "onArrowDown" in newProps || "onArrowLeft" in newProps || "onArrowRight" in newProps) {
			this.setupKeyboardHandlers();
		}

		if ("focusable" in newProps) {
			focusable[this.index] = newProps.focusable ?? false;
		}

		if ("tabIndex" in newProps) {
			tabIndex[this.index] = newProps.tabIndex ?? 0;
		}
	}

	getIndex() {
		return this.index;
	}

	destroy() {
		mouseDispatcher.removeHandlers(this.index);
		mouseHandlers[this.index] = null;

		if (this.keyboardUnsubscribe) {
			this.keyboardUnsubscribe();
			this.keyboardUnsubscribe = null;
		}

		cleanupComponent(this.index);
		releaseIndex(this.id);
	}
}

export function useBaseComponent(componentType, props, canHaveChildren = false) {
	const component = new BaseComponent(componentType, props, canHaveChildren);

	onMount(() => {});

	onDestroy(() => {
		component.destroy();
	});

	return component;
}