/* base-component-simple.svelte.ts generated by Svelte v5.38.7 */
import * as $ from 'svelte/internal/client';

import {
	allocateIndex,
	componentType,
	focusable,
	layoutProps,
	mouseDispatcher,
	mouseHandlers,
	releaseIndex,
	tabIndex,
	visibility,
	yogaNodes,
	focus,
	scrollable,
	scrollOffset,
	maxScrollOffset,
	computedHeight
} from '../core/state/engine.svelte.js';

import { applyTerminalProps } from '../core/layout/yoga-props-simple.mjs';
import { Yoga } from '../core/layout/yoga-instance.mjs';
import { setupComponent, cleanupComponent } from '../utils/hierarchy.svelte.js';
import { setupYogaNode } from '../core/layout/layout-simple.svelte.js';
import { keyboard } from '../input/keyboard.svelte.js';
import { onMount, onDestroy } from "svelte";
import { createSubscriber } from "svelte/reactivity";

export class SimpleBaseComponent {
	id;
	index;
	props;
	canHaveChildren;
	keyboardUnsubscribe = null;

	constructor(type, props, canHaveChildren = false) {
		this.id = `component-${Math.random().toString(36).substr(2, 9)}`;
		this.index = allocateIndex(this.id);
		this.props = props;
		this.canHaveChildren = canHaveChildren;
		componentType[this.index] = type;
		visibility[this.index] = true;
		setupComponent(this.index, canHaveChildren);
		setupYogaNode(this.index);

		if (props.focusable) {
			focusable[this.index] = true;
			tabIndex[this.index] = props.tabIndex ?? 0;
		}

		this.setupMouseHandlers();
		this.setupKeyboardHandlers();
		this.updateLayoutProps();
	}

	updateLayoutProps() {
		layoutProps[this.index] = this.props;

		const node = yogaNodes[this.index];

		if (node) {
			applyTerminalProps(node, this.props, Yoga);
		}
	}

	setupMouseHandlers() {
		const handlers = {};
		const p = this.props;

		if (p.onClick) handlers.onClick = (e) => {
			p.onClick(e);

			return true;
		};

		if (p.onMouseDown) handlers.onMouseDown = (e) => {
			p.onMouseDown(e);

			return true;
		};

		if (p.onMouseUp) handlers.onMouseUp = (e) => {
			p.onMouseUp(e);

			return true;
		};

		if (p.onMouseEnter) handlers.onMouseEnter = (e) => {
			p.onMouseEnter(e);

			return true;
		};

		if (p.onMouseLeave) handlers.onMouseLeave = (e) => {
			p.onMouseLeave(e);

			return true;
		};

		if (p.onMouseMove) handlers.onMouseMove = (e) => {
			p.onMouseMove(e);

			return true;
		};

		if (p.onWheel) handlers.onWheel = (e) => {
			p.onWheel(e);

			return true;
		};

		if (Object.keys(handlers).length > 0) {
			mouseHandlers[this.index] = handlers;
			mouseDispatcher.setHandlers(this.index, handlers);
		}
	}

	setupKeyboardHandlers() {
		const p = this.props;
		const hasHandlers = !!(p.onKeyPress || p.onEnter || p.onEscape || p.onSpace || p.onArrowUp || p.onArrowDown || p.onArrowLeft || p.onArrowRight || p.onfocus || p.onblur);

		if (!hasHandlers) return;

		if (this.keyboardUnsubscribe) {
			this.keyboardUnsubscribe();
			this.keyboardUnsubscribe = null;
		}

		this.keyboardUnsubscribe = keyboard.onFocused(this.index, (event) => {
			switch (event.key) {
				case "Enter":
					if (p.onEnter) {
						p.onEnter();

						return true;
					}
					break;

				case "Escape":
					if (p.onEscape) {
						p.onEscape();

						return true;
					}
					break;

				case " ":

				case "Space":
					if (p.onSpace) {
						p.onSpace();

						return true;
					}
					break;

				case "ArrowUp":
					if (p.onArrowUp) {
						p.onArrowUp();

						return true;
					}
					break;

				case "ArrowDown":
					if (p.onArrowDown) {
						p.onArrowDown();

						return true;
					}
					break;

				case "ArrowLeft":
					if (p.onArrowLeft) {
						p.onArrowLeft();

						return true;
					}
					break;

				case "ArrowRight":
					if (p.onArrowRight) {
						p.onArrowRight();

						return true;
					}
					break;
			}

			if (p.onKeyPress) return p.onKeyPress(event);

			return false;
		});
	}

	updateProps(newProps) {
		this.props = { ...this.props, ...newProps };
		this.updateLayoutProps();

		const mouseKeys = [
			"onClick",
			"onMouseDown",
			"onMouseUp",
			"onMouseEnter",
			"onMouseLeave",
			"onMouseMove",
			"onWheel"
		];

		if (mouseKeys.some((k) => k in newProps)) {
			mouseDispatcher.removeHandlers(this.index);
			mouseHandlers[this.index] = null;
			this.setupMouseHandlers();
		}

		const keyboardKeys = [
			"onKeyPress",
			"onEnter",
			"onEscape",
			"onSpace",
			"onArrowUp",
			"onArrowDown",
			"onArrowLeft",
			"onArrowRight",
			"onfocus",
			"onblur"
		];

		if (keyboardKeys.some((k) => k in newProps)) {
			this.setupKeyboardHandlers();
		}

		if ("focusable" in newProps) {
			focusable[this.index] = newProps.focusable ?? false;
		}

		if ("tabIndex" in newProps) {
			tabIndex[this.index] = newProps.tabIndex ?? 0;
		}
	}

	getIndex() {
		return this.index;
	}

	destroy() {
		mouseDispatcher.removeHandlers(this.index);
		mouseHandlers[this.index] = null;

		if (this.keyboardUnsubscribe) {
			this.keyboardUnsubscribe();
			this.keyboardUnsubscribe = null;
		}

		cleanupComponent(this.index);
		releaseIndex(this.id);
	}
}

export function useSimpleComponent(componentType, props, canHaveChildren = false) {
	const component = new SimpleBaseComponent(componentType, props, canHaveChildren);

	onDestroy(() => {
		component.destroy();
	});

	return component;
}